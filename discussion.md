I have this university project for a HCI (Human Computer Interaction) course that I have to do.

The idea is to Generate different (custom) layouts of keyboards (2-3), and calculate their theoretical WPM. We would pick keyboards whose WPM differ a good amount, and compare the resulting calculated average WPMs from users. 

This is the simplest implementation of the project, but there are a few details that needs to be discussed. For example, should we create an on-screen keyboard, which can then only be used on desktop, but we don't have to implement our own logging software that way. Would it be difficult to implement our own logging software. Next up, how would we design the keyboards? I have this elaborate idea of using a custom algorithm, but I won't mention it now because I think it depends on whether we use on-screen, or in-web. I assume the easiest tech stack would be to just use the web stack. That way, if we make a keyboard in the website, we can test on android also. To be clear, both keyboards would be on-screen, but one is embedded in the webpage (so, web layer), and the other is embedded in the OS.

Let's discuss this and clarify it in this file.

## Conversation summaries
- Turn 1 (2026-01-14): You asked to discuss this doc and to keep a 2–3 sentence, high-density summary of each conversation turn in `discussion.md`. I recommended keeping the experiment feasible/controlled by implementing all keyboard layouts as **web on-screen keyboards** (avoid OS-level keyboards), logging key events in-app, and defining a concrete movement+keypress time model over a corpus to compute “theoretical WPM” and pick 2–3 layouts with clearly separated predicted speeds.
- Turn 2 (2026-01-14): You agreed to keep everything in a website and asked whether logging is complicated, plus what “standard” theoretical-WPM models exist (keeping it simple/textbook for a prototype). I confirmed web logging is straightforward (timestamped key events + final text enables WPM, error rate, backspace/corrections, KSPC) and suggested simple theoretical models like **distance-based time** or **Fitts’ Law/KLM-style** time-per-keystroke summed over a phrase corpus, then converted to WPM.
- Turn 3 (2026-01-14): You chose a **linear distance** theoretical model for now and asked what other high-level decisions matter, plus which simple-but-upgradeable tech stack to use. I recommended locking down experiment design basics (baseline layout, phrase set, counterbalancing/order, metrics + logging format) and using a modular web stack (TypeScript + a small bundler) with separate modules for layout definition/generation, rendering, logging/metrics, and theoretical models so formulas/algorithms can be swapped later.
- Turn 4 (2026-01-14): You confirmed **QWERTY as control**, want fixed-phrase copy-typing, and for now only a minimal prototype (keyboard + textbox + CSV export), not full experimental counterbalancing. You also raised the key design question of **layout representation**, proposing **sequence-pair** placement as a future generation method, and asked to keep setup simple since you’re new to web dev.
- Turn 5 (2026-01-14): You agreed to keep a **trivial layout data structure** for the prototype and asked to wrap up, with the next step being a concrete coding plan next turn. We will keep the scope at “working web keyboard + textbox + logging + CSV export” while preserving clean seams for swapping layout generation and theoretical-WPM formulas later.
- Turn 6 (2026-01-14): You asked me to implement the agreed plan, so I built a **no-tooling** web prototype (`index.html` + `styles.css` + `src/*.js`) with layout selection (QWERTY/alpha/random), an on-screen keyboard, fixed-phrase copy trials, per-key event logging, WPM + edit distance + backspace metrics, and CSV/JSON export. It also includes a swappable **linear distance** theoretical model with a small table of predicted WPM per layout over the built-in phrase list.
- Turn 7 (2026-01-14): You said the prototype looks great and asked for the next major steps. I suggested moving from prototype → study by adding proper experiment flow (practice + counterbalanced blocks + participant/session IDs), an analysis pipeline, and then iterating on layout generation (e.g., sequence-pair) and model calibration using a small pilot.
- Turn 8 (2026-01-14): You said **no study mode** and **no analysis** for now, and instead wanted to lock in **sequence-pair** as the layout representation. You proposed per-key width/height parameters normalized to the fixed keyboard dimensions (with no gaps) and starting with a few simple sequence pairs to validate the generator works.
- Turn 9 (2026-01-14): I recommended keeping sequence pair as a **generator** that compiles into the existing runtime `{x,y,w,h}` rectangles, and normalizing via **global scaling** based on `max(x+w)` and `max(y+h)` (not per-key clamping) to preserve non-overlap/order. I also noted `A=[1..n], B=[1..n]` gives a horizontal chain (good sanity test) and flagged that “no gaps” is mostly a rendering choice.
- Turn 10 (2026-01-14): You confirmed sequence-pair should include **space + backspace** (and be extensible to more keys later) but insisted **no special sizing**—space/backspace must be treated like any other key (uniform default weights).
- Turn 11 (2026-01-14): We converged on a minimal `SequencePairSpec`: explicit `keys[]` (index→key mapping), two permutations `seqA/seqB`, optional size arrays defaulting to 1, plus normalization to a fixed keyboard bounding box and gapless rendering. Next step is implementing `compileSequencePair()`, adding a few test SP layouts, and verifying it in the prototype.
- Turn 12 (2026-01-14): You asked for a concrete implementation plan and then to implement it; I added **sequence-pair compilation** (permutation validation + O(n²) packing + global scaling to canonical bounds), plus three SP test layouts (identity, reverse-B, mixed). I also set keyboard rendering to **no inter-key gap** and verified in-browser that SP layouts render and typing/export still work.
- Turn 13 (2026-01-14): You requested two more sequence-pair layouts: one with **random permutations + fixed sizes**, and one with **random permutations + random sizes**. I implemented both as reproducible seeded layouts and added them to the layout dropdown.
- Turn 14 (2026-01-14): You asked to remove the seeded PRNG (`mulberry32`) and keep randomness simple (layouts may change on reload). I removed the custom generator and switched the random sequence-pair layouts to use `Math.random()` for shuffling and size sampling.
- Turn 15 (2026-01-14): You observed occasional **visual overlaps** in generated layouts and questioned whether the SP packing is using the correct `x/y + w/h` predecessor rule. I confirmed the SP math already uses `x[j] >= x[i]+w[i]` / `y[j] >= y[i]+h[i]`, and fixed the real cause: the renderer was clamping min pixel sizes (which can force overlaps); I removed that clamp and added an O(n²) unit-space overlap sanity-check in `compileSequencePair()`.
- Turn 16 (2026-01-14): You asked to document everything we’ve done so far and treat it as a new baseline. I added a concise project snapshot in `README.md` (run steps, file map, layout/sequence-pair representation, key algorithms, and known artifacts) so we can “start fresh” from a stable written spec.
- Turn 17 (2026-01-14): You proposed a separate **live generator screen** to continuously sample random sequence-pair layouts in the background, score only by theoretical WPM (distance-linear), and keep a live top-5 leaderboard with preview and a toggle for random key sizes. I implemented `generator.html` + `src/generatorApp.js` to run the loop, update the leaderboard on improvements, and reuse the existing keyboard renderer for previews.
- Turn 18 (2026-01-14): You chose **Project Gutenberg** as a more representative corpus and asked to keep it in a separate folder. I added `corpus/gutenberg/` with a small build script + a generated bigram-count dataset (letters+space) and updated the generator scoring to use this Gutenberg-derived distribution (still distance-linear WPM), falling back to the small phrase list if the corpus file isn’t present.
- Turn 19 (2026-01-14): You requested that missing bigrams should be **fatal** (no silent fallback) and asked for a way to **inspect bigram counts** in the generator UI. I updated the generator to require `ns.corpus.gutenberg` to start/scoring, and added a “Corpus” section in `generator.html` showing metadata + top bigrams and a JSON download.
- Turn 20 (2026-01-14): You requested that bigrams display spaces as `_` (e.g., `e_` instead of `e␠`) and that the percentage column be rounded to **2 decimals**. I updated the corpus table rendering accordingly in `src/generatorApp.js`.
- Turn 21 (2026-01-14): You decided to switch from distance-linear to a more sophisticated model and asked to implement **Fitts’ Law** scoring. I added a Gutenberg-bigram-weighted Shannon Fitts scorer (with directional effective width) and switched the generator to use it, so key size now influences predicted movement time and scores.

## Current decisions (as of 2026-01-14)
- **Platform**: Web app with on-screen keyboards (works on desktop + mobile browser); avoid OS-level keyboards.
- **Layouts**: QWERTY control + 1–2 custom/generated layouts.
- **Runtime layout format**: Keys as `{id,label,type,x,y,w,h}` in abstract units (rendering + distance calculations use coordinates); generators (manual rows or sequence-pair) compile into this.
- **Sequence-pair (next)**: `keys=a..z+space+backspace` initially; uniform default sizes; compile SP → non-overlapping rectangles, then globally scale to a fixed keyboard bounding box (extensible to more keys later).
- **Rendering (prototype)**: No inter-key spacing (gapless); all sizing is handled in unit-space then scaled to the container.
- **Task (prototype)**: Copy-typing fixed phrases; no counterbalancing/order effects work yet.
- **Logging/metrics/export**: Log per-key events + final typed string + timing; compute WPM + error rate (edit distance) + backspace count/KSPC; export CSV (JSON optional).
- **Theoretical model (prototype)**: Linear distance-based time model over a phrase corpus; swappable later.